{
  "hash": "833a12eba2f13a5bf643c138a069baa4",
  "result": {
    "markdown": "---\ntitle: \"Making a Logo for your R package---Using R\"\ndescription: \"In this post, I explain how I made the logo for the ggchameleon package using nothing but R!\"\nauthor: \"Aaron Graybill\"\ndate: \"11/17/2023\"\nexecute: \n  freeze: auto\ncategories: \n  - R\n  - Images\n  - ggplot2\n---\n\n\n## Introduction\n\n:::: {layout=\"[[30,-2,70]]\" layout-valign=\"center\"}\n\n::: {.intro-card}\n![](logo.png){fig-alt=\"The logo for ggchameleon\"}\n\n:::\n\n::: {intro-text}\n\nI'm the author of the [ggchameleon R package](https://github.com/aarongraybill/ggchameleon). While making this package, I learned a great deal about how to massage [ggplot2](https://ggplot2.tidyverse.org/) charts to automatically display a customized \"brand\" (font, colors, layout, etc.). I also learned about how to do math to colors to make sure that gradients look normal to humans. Humans are weird, so the math to represent our color vision is equally weird. When I made the logo for this package, both of those two skills proved to rather useful. In this post, I'm going to walk through how I constructed that logo in a fully reproducible way using R.\n\n:::\n\n::::\n\n## Stylistic Constraints\n\nIf you look at the logos for various R packages, you'll find that they tend to follow the format exemplified [here](https://github.com/rstudio/hex-stickers). From those exemplars, I decided that my logo should:\n\n1. Fit in a hexagon with a notable border\n2. Have the name of the package clearly visible\n3. Have a minimalist, geometric image representing a package\n\nFrom these constraints, a natural choice is use a chameleon as the primary image. However, I am not an artist, so I needed a way to convert an existing image into a minimalist, geometric representation of a chameleon.\n\n## The input image\n\nWikipedia is a subsidiary of the [Wikimedia Foundation](https://www.wikimedia.org/). The Wikimedia Foundation does much more than just run Wikipedia, but pertinent now is the [Wikimedia Commons](https://commons.wikimedia.org/wiki/Main_Page) which hosts media (images, videos, sounds, etc.) for free, for the public benefit. When you see an image on a Wikipedia article, you are likely viewing an image hosted on the Wikimedia Commons.\n\nThe other wonderful upside of the Wikimedia Commons is that many of the images are given the [Creative Commons License](https://creativecommons.org/licenses/by-sa/4.0/deed.en) which means that users can freely adapt these images to their own uses (even commercial!). In my case, I selected this incredible [image of a chameleon](https://en.wikipedia.org/wiki/File:Panther_chameleon_(Furcifer_pardalis)_male_Nosy_Be.jpg#file) as the base for my logo:\n\n[![The base image for my logo, by Charles Sharp](Panther_chameleon_(Furcifer_pardalis)_male_Nosy_Be.jpg){fig-alt=\"Image of a Chameleon\"}](https://en.wikipedia.org/wiki/File:Panther_chameleon_(Furcifer_pardalis)_male_Nosy_Be.jpg#file)\n\n## Removing the image background using R\n\nThe input image has a background that has beautiful [bokeh](https://en.wikipedia.org/wiki/Bokeh), but the rectangular shape of the image fits awkwardly into our hexagonal box. Let's remove the background of the image so that we only have the chameleon and the stick he's perched on. There may be ways to do this in R, but it's much simpler and more effective to outsource this task to a dedicated service. Thankfully, we can tell R to access such a service directly through an API. In particular, I use the free API available at [remove.bg](https://www.remove.bg/api). This service works perfectly but requires you to use an API key (so that they know who you are when you send a request). In general, it is bad practice to publicly share your API key, so the following code has the API key hidden in a private file. Substituting `readLines('bg_api_key')` with a string like `\"my_cool_api_key\"` should make the code work as expected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(httr)\n\npayload <- list(\n  image_url = 'https://upload.wikimedia.org/wikipedia/commons/2/2d/Panther_chameleon_%28Furcifer_pardalis%29_male_Nosy_Be.jpg',\n  size = 'auto'\n)\nresult = POST(url = 'https://api.remove.bg/v1.0/removebg',\n              body = payload,\n              add_headers(`X-Api-Key` = readLines('bg_api_key')),\n              encode= 'json'\n)\n\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nResponse [https://api.remove.bg/v1.0/removebg]\n  Date: 2024-04-29 01:13\n  Status: 200\n  Content-Type: image/png\n  Size: 189 kB\n<BINARY BODY>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nNULL\n```\n:::\n:::\n\n\nThe status code 200 indicates that our request has been processed successfully. When our request is successful, the API returns binary data encoding the png image that we can write to our local machine for further processing. I do that as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout <- content(result)\npng::writePNG(out,'chameleon.png')\n\nlibrary(magick)\nchameleon <- image_read('chameleon.png')\nplot(chameleon)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){fig-alt='An image of a chameleon with the background removed' width=672}\n:::\n:::\n\n\nYou can see that the API did an excellent job of removing the background from the image! Onto the next task...\n\n## Converting the image to a geometric design\n\nThe image above is still rather intricate (chameleons are beautifully intricate creatures), but one our goals was to simplify the image into a simpler set of geometric shapes. To do this, I had the idea to take the brightness of each pixel and treat that as a value that I could put into a contour map. A contour map is often used to visualize changes in elevation, as shown below in the underwater mountain [Resolution Guyot](https://en.wikipedia.org/wiki/Resolution_Guyot):\n\n[![An example of a contour map by Balon Greyjoy](Resolution_Guyot_contour_map.png){fig-alt=\"An example of a contour map\" width=\"60%\"}](https://commons.wikimedia.org/wiki/File:Resolution_Guyot_contour_map.png#)\n\nIn the above example, redder areas indicate higher regions, and bluer areas indicate lower regions. You can tell that the contour map is able to convert the complex surface of the mountain into a series of simpler geometric shapes. I use this idea by treating pixel brightness as the \"height\".\n\nI admit, the code becomes a bit complicated here, so I have \"folded\" it so as not to clutter this post, but here's an outline of what the code does:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Compute Brightness\"}\n# Make the image smaller and extract the pixel level information\ndf <- image_data(image_scale(chameleon,\"100\"))\n\n# The pixel data is a 3D array (red, blue, green)\n# we can paste each of those channels into the standard hex color \n# of the format: #FF00FF\n# I then convert all of those hex codes into a matrix with the same dimensions\n# as the rescaled image\nm <- \n  paste0(\"#\",df[1,,],df[2,,],df[3,,]) %>% \n  matrix(nrow = dim(df)[2],ncol=dim(df)[3])\n\n# The \"row\" function returns the row number of every element in the matrix\n# we treat that row number as an x coordinate\n# we do a similar thing with the columns using the \"col\" function\n# we have to be careful to transpose the matrix as needed,\n# We use the \"c\" function to flatten the matrix of row numbers into a vector\n# and we multiply by -1 because pixels start in the top left, but when we plot\n# we want to start in the bottom left\noutdf <- data.frame(x = c(t(row(m))),y = -1*c(t(col(m))), hex = c(t(m)))\n\nlibrary(dplyr)\nbrightness_df <- outdf %>%\n  # Convert the color to a \"colorspace\" that has a brightness component and\n  # is perceptually uniform, ie a one unit increase in brightness means the\n  # same thing for all colors\n  # then we extract the luminance (brightness) and treat that as \n  # the outcome variable\n  mutate(luminance = {farver::decode_colour(hex) %>% farver::convert_colour(\"rgb\",\"lab\")}[,1]) %>%\n  mutate(luminance = floor(luminance))\n```\n:::\n\n\n1. Rescale the image so that it's small enough to generate simple contours\n2. Convert the image into a data frame of each pixel's coordinates and its color\n3. Compute the brightness (technically luminance) of each color in the image\n\nAfter we do all of that, we have a dataframe that looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbrightness_df %>% \n  head() %>% \n  knitr::kable()\n```\n\n::: {.cell-output-display}\n|  x|  y|hex     | luminance|\n|--:|--:|:-------|---------:|\n|  1| -1|#000000 |         0|\n|  1| -2|#000000 |         0|\n|  1| -3|#000000 |         0|\n|  1| -4|#000000 |         0|\n|  1| -5|#000000 |         0|\n|  1| -6|#000000 |         0|\n:::\n:::\n\n\nAnd we can plot the luminance directly and we will see something resembling a grayscale image of our scaly friend:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(brightness_df)+\n  geom_point(aes(x=x,y=y,color=luminance))+\n  scale_color_gradient(low=\"black\",high = \"white\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){fig-alt='A scatter plot of pixel brightness' width=672}\n:::\n:::\n\n\nThat's cool, but a little busy, let's simplify the image using ggplot's `geom_contour_filled` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(brightness_df)+\n  geom_contour_filled(aes(x=x,y=y,z=luminance),bins=5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){fig-alt='A plot of contours of chameleon brightness' width=672}\n:::\n:::\n\nThat is much closer! What remains is for us to remove unnecessary elements of that plot, customize the colors, and add the design to the hexagonal tile.\n\n## Cleaning up, Customizing, and Hexagoning\n\nAgain, I've \"folded\" the cleaning of the chart for sake of brevity, but feel free to unfold it and take a look at what manipulations are required. The result of the cleaning is the following:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Clean Chart\"}\n# Custom color scheme\npal <- c(\"#000D4D\",'#26442E','#5A9550','#7DF279','#FFF200')\npal[1] <- '#00000000' #Sets background color to transparent\n\n# Create cleaned-up plot\np <- ggplot(brightness_df)+\n  # make sure there are no lines between contours\n  geom_contour_filled(aes(x=x,y=y,z=luminance),bins = 5,linewidth=0)+\n  # makes the image's aspect ratio true-to-life\n  coord_equal()+\n  # removes all extraneous plot info (axes, lines, etc.)\n  theme_void()+\n  # customize the fill colors\n  scale_fill_manual(values = pal)+\n  # don't print the legend\n  theme(legend.position = \"None\")+\n  # remove the x and y axis labels\n  xlab(NULL)+\n  ylab(NULL)\n\n# Print the updated chart\np\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){fig-alt='Contour image of a chameleon with no background' width=672}\n:::\n:::\n\nNow, we need to place our simplified chameleon onto the hexagonal tile. Thankfully, the [hexSticker](https://github.com/GuangchuangYu/hexSticker) package makes it easy to generate these hexagonal tiles and add our own images on top. First we save a rotated version of the chameleon so that it's parallel to the hexagon, then we overlay that saved version onto the tile generated by hexSticker. We can do that as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Save the rotated ggplot as a svg (infinite resolution)\nlibrary(grid)\nsvg(\"rotated_contour_chameleon.svg\", bg = \"#00000000\")\nprint(p, vp = viewport(angle = 30))\ncapture_output = dev.off()\n\n# Add the brand font into available fonts\nsysfonts::font_add_google('Atkinson Hyperlegible',\n                          regular.wt = 700)\n\n# Generate the Hexagon with the image on top\nlibrary(hexSticker)\nsticker(\"rotated_contour_chameleon.svg\",\n        package=\"ggchameleon\", # text on the image\n        s_height= .90, # svg image size\n        s_width = .90,\n        h_fill = '#000D4D', # background color\n        h_color = '#7DF279', # border color\n        s_x = 1.23, # location of image \n        s_y = .8,\n        p_x = .99, # location of text\n        p_y = 1.42, \n        p_size = 6, # font size\n        p_color = '#E7F6F4', # font color\n        p_family = 'Atkinson Hyperlegible' # font family\n) %>% plot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){fig-alt='The newly generated logo' width=672}\n:::\n:::\n\n\nAnd that's it! Feel free to remix this code with your own images. I think other animals or distinctive architecture could look interesting, but I'd be interested to see what else can be done using these techniques.",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}