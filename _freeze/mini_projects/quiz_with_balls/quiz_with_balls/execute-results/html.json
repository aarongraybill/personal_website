{
  "hash": "0604c20ab3c263f8f3078a9e4f97a436",
  "result": {
    "markdown": "---\ntitle: \"The Simulation With Balls\"\ndescription: \"Simulating the scoring system of *The Quiz With Balls* to understand if it is fair.\"\nauthor: \"Aaron Graybill\"\ndate: \"7/02/2024\"\nexecute: \n  freeze: auto\ncategories: \n  - python\n  - ggplot2\n  - simulation\n  - just-for-fun\n---\n\n\n## Introduction\n\n:::: {layout=\"[[30,-2,70]]\" layout-valign=\"center\"}\n\n::: {.intro-card}\n![](pdf_with_balls.svg){fig-alt=\"A Gaussian density function with balls rolling down\"}\n\n:::\n\n::: {intro-text}\n\nIn May 2024, Fox began airing *The Quiz With Balls*. The show features\ntwo teams of five competing in lighthearted trivia questions. The\ngimmick of the show is that any contestant who answers incorrectly is\nknocked into a pool of water by one the titular balls. Points escalate\neach round, and the family with the most points after five rounds gets\nto play for \\$100,000.\n\n:::\n\n::::\n\nThe show itself is kind of interesting, but the scoring is strange. My\nmathematical gut was telling me that the first round should very often\ndetermine the outcome of the entire game. Thus began my deep dive into\nthe scoring and probability of *The Quiz With Balls*.\n\nAs a teaser, the scoring of *The Quiz With Balls* allows you to turn off your TV\nafter the first round more than 25% of the time because you will already know \nthe winner. Sometimes you will know with more than 90% certainty after the \nfirst round!\n\n## How *The Quiz With Balls* Works\n\nBefore diving into the math, I need to explain how *The Quiz With\nBalls* works.\n\nThere are two teams of five. I'll call the teams $A$ and $B$. There are\nup to five rounds. Each round has two essentially identical stages. In\nstage one of round one, team $A$ chooses one of ten categories. The\ncategories broadly indicate the subject of the question, but are not\nspecific enough to credibly inform contestants. Once team $A$ has chosen\ntheir category, they are presented with the question. The question\nalways has 6 options and as many correct answers as players remaining\nin that team. So at the start of the game, there are still\n5 players on team $A$, so there will be 6 possible answers 5 of which are \ncorrect.\n\nTeam $A$ must then decide to assign their 5 contestants into 5 of\nthe 6 possible options. Players may not double-up on the same answer or\nchoose to sit out. Players walk into a slot corresponding to their\nselected answer. Then the correct answers are revealed by six balls\nrolling down the slots. If an answer is correct, the ball stops just\nbefore hitting the contestant. If an answer is incorrect, the ball rolls into\nthe player, knocking them into the pool, and removing them from the rest of the game. So if team $A$ gets an incorrect answer in the first round, they will start the next round with $4$ players. There is no mechanism for players to return to\nthe team once they have been knocked into the pool.\n\nThe second stage of round one is for team $B$. They select one of the\nnine remaining categories, they are given the question, they assign\ntheir five players to five slots, and then the balls reveal which answer\nwas correct.\n\nThen, in round 2 the game proceeds as before, but now with as many\ncorrect answers as remaining players. For example, if there are 4\nplayers remaining on team $A$, and the question is: \"Which of the\nfollowing are shades of red?\" You may have answers like:\n\n1.  **Carmine** [■]{style=\"color:#960018;\"}\n2.  Chartreuse [■]{style=\"color:#80FF00;\"}\n6.  Maize [■]{style=\"color:#FBEC5D;\"}\n5.  **Salmon** [■]{style=\"color:#FA8072;\"}\n4.  **Scarlet** [■]{style=\"color:#FF2400;\"}\n3.  **Vermilion** [■]{style=\"color:#D9381E;\"}\n\nThe boldface answers are correct.[^1] Since there were four players\nremaining, there were four correct answers. (Of course, the contestants would\nnot see the boldfacing or the colored blocks).\n\nPlay continues until 5 rounds have elapsed or one team loses all\nof its players.\n\nScoring is cumulative between rounds, and the number of points in round\n$t$ is equal to $\\$1,000$ times $t$ times the number of correct answers in that\nround. So 3 correct answers in round 4 would give\n$\\$1,000\\cdot4\\cdot3=\\$12,000$.\n\nThe team with the most points at the end of round 5 then plays a\nminigame for the chance to win $\\$100,000$. I will not model this final\nround because I am more interested in the competition between the two\nteams.\n\n[^1]: Colors taken from [here](https://en.wikipedia.org/w/index.php?title=List_of_colors:_A%E2%80%93F&oldid=1230664561), [here](https://en.wikipedia.org/w/index.php?title=List_of_colors:_G%E2%80%93M&oldid=1229619890), and [here](https://en.wikipedia.org/w/index.php?title=List_of_colors:_N%E2%80%93Z&oldid=1229619855).\n\n## Modeling *The Quiz With Balls*\n\nIn this section, I will model the probability of a team going from one\nnumber of players in round $t$ to another number of players in round\n$t+1$.\n\nSuppose that there are $b$ total balls[^2] and $p$ remaining players in\nround $t$. The host will then generate a question with $p$ correct\nanswers, one for each player. We want to determine the probability that\n$j$ players get the question correct given that there are $p$ remaining\nplayers and $b$ possible options.[^3] If $j$ players get the question\ncorrect, then $j$ players advance to the next round.\n\n[^2]: There's only ever $6$ balls, but the $b$ just helps to generalize\n    the thinking.\n\n[^3]: There is a little bit of strategy when deciding which player to\n    allocate to which answer, but usually the answers are so low\n    confidence that we can reasonably model the players as randomly\n    deciding on the answer.\n\nThe easiest way to proceed is to break the probability into something\nlike: \n\n$$\n\\frac{\\# \\text{ of ways to get }j\\text{ correct}}{\\# \\text{ of total outcomes}}\n$$\n\nThe numerator is a little challenging, but it can be split into three\nsubproblems:\n\n1.  How many ways are there to choose which of the $p$ are in the $j$\n    correct slots?\n2.  Within the correct $j$ players, how many ways are there to allocate\n    them into the $p$ correct slots (since there are always $p$ correct\n    answers)?\n3.  Within the incorrect $p-j$ players, how many ways are there to\n    allocate them into the $b-p$ incorrect slots.\n\nThere is a subtle difference between the first question and the latter\ntwo. In the first question, we do not care about the actual ordering of\nthe players within their group, we only care about *who* will respond\ncorrectly (not which answer they will respond to). In the latter two\nquestions, we are able to use our knowledge of *who* is in each group to\nask *where* each person will be allocated. So for the first question, we\ndo not care about ordering, but in the latter two, we do care about\nordering.\n\nAlso, you may be asking why we don't have to answer a question like:\n\"How many ways are there to choose which players in the *incorrect*\nslots?\" We do not need to determine that quantity because it is always\nexactly determined by the people who get the question correct. Since\nthere are only two categories, once you have chosen the correct players,\nthen all of the other players fall into the incorrect bin. So this\nquestion would not introduce any new scenarios.\n\nStarting with question 1., this is simply the number of ways to choose\n$j$ players from $p$ choices, so $nCk(p,j)=\\frac{p!}{j!(p-j)!}$. Since\neach player must be allocated to exactly one slot, we can use the\ncombination formula.\n\nFor question 2., this is the number of ways to order $j$ players within\n$p$ slots, or $nPk(p,j)=\\frac{p!}{(p-j)!}$.\n\nAnd finally, for question 3, we ask how many ways are there to order the\n$p-j$ into $b-p$ slots, so\n$nPk(b-p, p-j)=\\frac{(b-p)!}{((b-p)-(p-j))!}$. Notice that 1., 2., and\n3. do not depend on each other, so the total number of ways to get $j$\ncorrect answers is the product of the three quantities.\n\nSo the total number of ways to get $j$ correct given that you currently\nhave $p$ players is:\n\n$$\n\\text{\\# of ways for} \\ j \\ \\text{correct answers} = \\frac{p!}{j!(p-j)!} \\cdot \\frac{p!}{(p-j)!} \\cdot \\frac{(b-p)!}{((b-p)-(p-j))!}\n$$\n\nThen, let's tackle the denominator. Here we're trying to count the total\nnumber of outcomes. Notice that the total number of ways to allocate $p$\nplayers in to $b$ slots is $nPk(b,p)=\\frac{b!}{(b-p)!}$. So the\nprobability of starting with $p$ players, and getting $j$ correct\nanswers is:\n\n$$\nf(j,p,b)=\\frac{\\frac{p!}{j!(p-j)!} \\cdot \\frac{p!}{(p-j)!} \\cdot \\frac{(b-p)!}{((b-p)-(p-j))!}}{\\frac{b!}{(b-p)!}}\n$$\n\nThis expression does not simplify nicely, so we will use $nPk$ and $nCk$\ndirectly when computing probabilities. Despite the relative inelegance\nof the above expression, it turns out to be quite powerful when modeling\n*The Quiz With Balls*. Now, we are able to take any game state (the\ncurrent number of remaining players), and predict the distribution of\ngame states in the next period.\n\nLet's implement this function $f$ in python:\n\n\n::: {.cell python.reticulate='false'}\n\n```{.python .cell-code}\nimport numpy as np\nimport math\n\n# Create a version of nPk that doesn't do more computation than necessary\ndef nPk(n: int, k: int) -> int:\n  # uses a ternary expression to return 0 if trying to choose more than available\n  return np.prod(range(n-k+1,n+1)) if k<=n else 0\n\ndef f(j: int, p: int, b: int) -> float:\n  numerator = math.comb(p,j) * nPk(p, j) * nPk(b-p,p-j)\n  denominator = nPk(b,p)\n  return (numerator/denominator)\n\nf(4,5,6)\n```\n:::\n\n\nThe last line of the above says that the probability of getting 4\ncorrect answers when you have 5 players and 6 balls is 83%.\n\nThis function $f$ allows us to consider the probability of going from\nany number of players $p$, to any number of correct answers $j$. \n\n## Win Probability\n\nEven with all of this technology, it is difficult to exactly compute the\nprobability that a team will win given certain conditions. Getting win\nprobabilities essentially requires us to determine the probabilities of\ncertain point totals. Point totals are very difficult to reason about\nbecause they depend on both the number of correct answers *and* the\nrounds in which those answers took place (since points escalate each\nround). For example, a team that has the sequence of number of correct\nanswers $5,4,2,2$ has the same point total as a team that has a sequence\n$4,3,3,2$ when you account for escalating point values.\n\nBut we're not completely without hope, even if we can't compute the ex\nante probabilities of certain point totals, we can easily compute the\npoint total of any given sequence of outcomes. And since we can easily\npredict the probability of going from one state to another, we can\nsimulate many games, and empirically determine win probabilities given\ncertain conditions.\n\nBelow, I construct a python class outlining how a team can play in *The\nQuiz With Balls*. I then create a class to describe how multiple teams\nplay a game. The details aren't essential, this just allows me to\nquickly simulate many games. I have \"folded\" the code, but feel free to\ntake a look if you are interested.\n\n\n::: {.cell python.reticulate='false'}\n\n```{.python .cell-code  code-fold=\"true\" code-summary=\"Create Team Class\"}\nfrom string import ascii_uppercase\nfrom numpy.random import choice\nimport pandas as pd\n\nclass Team:\n  \n  def __init__(self, n_balls: int, name: str = None):\n    \n    self.finished = False\n    \n    self.n_balls = n_balls\n    \n    self.name = name\n    if self.name is None:\n      # if no name was given, make it a random string\n      self.name = ''.join(choice(ascii_uppercase) for i in range(6))\n  \n    self.players = self.n_balls - 1\n    self.points = 0\n  \n    self.player_history = [self.players]\n    self.point_history = [self.points]\n    \n    # for each combination of j and p, compute the probability\n    x = [f(j,p,self.n_balls) for j in range(self.n_balls) for p in range(self.n_balls)]\n    \n    # convert the 1D array of probabilities to a matrix\n    # and transpose so indexes are as expected\n    self.M = np.reshape(x, (-1,self.n_balls)).T\n  \n  def play_round(self, round_number: int):\n    \n    # If not finished, run a simulation\n    if not self.finished:\n      probs = self.M[self.players, :]\n      \n      self.players = np.random.choice(range(self.n_balls),1,p=probs)[0]\n      self.points += round_number * self.players\n      # If you're ending the round with zero players, you're finished\n      if self.players == 0:\n        self.finished = True\n    \n    # Either way, append info to the history\n    self.player_history.append(self.players)\n    self.point_history.append(self.points)\n      \n    return (self.players, self.points)\n  \n  def rig_round(self, round_number, n_correct):\n    assert self.players >= n_correct\n    # If not finished, rig this round\n    if not self.finished:\n      \n      self.players = n_correct\n      self.points += round_number * self.players\n      # If you're ending the round with zero players, you're finished\n      if self.players == 0:\n        self.finished = True\n    \n    # Either way, append info to the history\n    self.player_history.append(self.players)\n    self.point_history.append(self.points)\n    \n  def summarize(self):\n    out = {\n      'name' : self.name,\n      'players': self.players,\n      'points': self.points\n      }\n      \n    return out\n```\n:::\n\n::: {.cell python.reticulate='false'}\n\n```{.python .cell-code  code-fold=\"true\" code-summary=\"Create Game Class\"}\nclass Game:\n  def __init__(self, n_balls=6, n_teams=2):\n    assert n_teams <= 26 # needed for team naming\n    self.n_balls = n_balls\n    self.n_teams = n_teams\n    self.finished = False\n    self.round_number = 1\n    self.winner = None\n    self.teams = [Team(self.n_balls, name = ascii_uppercase[i]) for i in range(self.n_teams)]\n    \n  def is_finished(self):\n    finished_teams = np.sum([t.finished for t in self.teams])\n    one_remaining = finished_teams >= (self.n_teams - 1)\n    out_of_turns = self.round_number > 5\n    # The game is over as soon as there is only one team not \n    # finished\n    return one_remaining | out_of_turns\n  \n  def play(self):\n    \n    #while self.finished is False:\n    while not self.finished:\n      # Keep playing until all teams are out\n      [t.play_round(self.round_number) for t in self.teams]\n      self.round_number += 1\n      self.finished = self.is_finished()\n\n    # Print score at end of game\n    scores = [t.points for t in self.teams]\n    \n    # Test to see if it's not a tie\n    if any(scores[0]!=scores[1:]):\n      self.winner = np.argmax(scores)\n      return None\n  \n  def summarize_game(self):\n    x = [t.summarize() for t in self.teams]\n    df = pd.DataFrame(x)\n    df['won'] = [self.winner == i for i, _ in enumerate(self.teams)]\n    df['round'] = self.round_number\n    return df\n    \n\n```\n:::\n\n::: {.cell python.reticulate='false'}\n\n```{.python .cell-code  code-fold=\"true\" code-summary=\"Simulation Logic\"}\ndef simulate(n: int = 10000, WorkingGame = Game):\n  summaries = []\n  for i in range(n):\n    g = WorkingGame()\n    g.play()\n    df = g.summarize_game()\n    df['game_no'] = i\n    summaries.append(df)\n    \n  df = pd.concat(summaries)\n  # make sure index isn't duplicated\n  df = df.reset_index(drop = True)\n  \n  df['rigging'] = WorkingGame.__name__\n\n  return df\n```\n:::\n\n\n### Baseline Results\n\nNow, we have everything we need to simulate *The Quiz With Balls*. I am\ninterested in how the results of the first round determine the rest of\nthe game, but to make sure that everything is working as expected, let's\nsimulate 10,000 games completely randomly.\n\n\n::: {.cell python.reticulate='false'}\n\n```{.python .cell-code}\nnp.random.seed(0)\ndf = simulate(n=10000)\n\ndf.to_csv('unfavored.csv', index = False)\n```\n:::\n\n\nHere, since we started symmetrically, we should expect teams $A$ and $B$\nto win a roughly equal number of games. Below I plot the simulated fraction of \ngames won by team $A$ and team $B$.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot Simulated Games\"}\nlibrary(ggplot2)\nlibrary(ggchameleon)\n\nlibrary(dplyr)\n\ndf <- read.csv('unfavored.csv') \nwin_counts <- \n  df |> \n  summarize(winner = case_when(\n    any(name==\"A\" & won=='True') ~ \"A Wins\",\n    any(name==\"B\" & won=='True') ~ \"B Wins\",\n    T ~ \"Tie\"\n  ),\n  .by = game_no) |> \n  filter(winner!='Tie') |> \n  summarize(n = n(), .by = winner) |> \n  mutate(total = sum(n)) |> \n  rowwise() |> \n  mutate(ci = list(binom.test(n,total)$conf.int)) |> \n  mutate(ci_lower = ci[1],\n         ci_upper = ci[2])\n\nb_test <- binom.test(win_counts$n[1], win_counts$total[1])\np_val_fmt <- format(b_test$p.value, digits = 4)\n\n# Only need to check the first test since they're actually the same\nfail_to_reject <- all( (win_counts$ci_lower<=.5) & (win_counts$ci_upper>=.5) )\nstopifnot(fail_to_reject)\n\nn_sims <- nrow(df)/2\nn_ties <- n_sims - win_counts$total[1]\n\ngg <- \n  ggplot(win_counts)+\n  geom_col(aes(x=winner, y =n/sum(n)))+\n  geom_errorbar(aes(x=winner,ymin=ci_lower,ymax=ci_upper),width = 0.2)+\n  ggtitle(\"Fraction of Games Won by Each Team\",\n          \"95% Confidence Intervals of Winning Probability\")+\n  xlab(NULL)+\n  ylab(NULL)+\n  labs(caption = glue::glue(\"{n_ties}/{n_sims} simulations excluded due to ties\"))\n\ngg\n```\n\n::: {.cell-output-display}\n![](quiz_with_balls_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nSince there is randomness in the games, the observed win probabilities are not\nexactly equal. However, a binomial test reveals that the win probabilities are not\nsignificantly different from each other ($p$-value 0.7772).\n\n### If Team $A$ Wins the First Round\n\nFinally, let's tackle my initial question: if team $A$ does better in the first\nround, what is the probability that they win the entire game? In particular,\nI will run another 10,000 simulations. Instead of starting at the beginning\nof the game, we will start each game in the second round. We will override the \nfirst round so that team $A$ got all 5 correct, but team $B$ lost a player, and \nonly got 4 correct. Then we let the natural simulation dynamics play out for the\nrest of the game.\n\n\n\n::: {.cell python.reticulate='false'}\n\n```{.python .cell-code}\n# Create a class inheriting from the standard game \nclass FavorA(Game):\n  def __init__(self):\n    # Creates the unbiased game\n    super().__init__()\n    # Override the first round to favor A\n    self.teams[0].rig_round(1,5)\n    self.teams[1].rig_round(1,4)\n    self.round_number = 2\n\n# Run simulation favoring A\nnp.random.seed(1)\ndf = simulate(n=10000, WorkingGame = FavorA)\n\ndf.to_csv('favor_a.csv', index = False)\n```\n:::\n\n\nReproducing the same plot from before, we have:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot Games Favoring A\"}\ndf <- read.csv('favor_a.csv')\nwin_counts <- \n  df |> \n  summarize(winner = case_when(\n    any(name==\"A\" & won=='True') ~ \"A Wins\",\n    any(name==\"B\" & won=='True') ~ \"B Wins\",\n    T ~ \"Tie\"\n  ),\n  .by = game_no) |> \n  filter(winner!='Tie') |> \n  summarize(n = n(), .by = winner) |> \n  mutate(total = sum(n)) |> \n  rowwise() |> \n  mutate(ci = list(binom.test(n,total)$conf.int)) |> \n  mutate(ci_lower = ci[1],\n         ci_upper = ci[2])\n\nb_test <- binom.test(win_counts$n[1], win_counts$total[1], p = .9, alternative = \"greater\")\nlower_bound <- format(b_test$conf.int[1]*100, digits = 4, scientific = F) \n\n# Only need to check the first test since they're actually the same\nstopifnot(b_test$p.value<.05)\n\nn_sims <- nrow(df)/2\nn_ties <- n_sims - win_counts$total[1]\n\ngg <- \n  ggplot(win_counts)+\n  geom_col(aes(x=winner, y =n/sum(n)))+\n  geom_errorbar(aes(x=winner,ymin=ci_lower,ymax=ci_upper),width = 0.2)+\n  ggtitle(\"Fraction of Games Won by Each Team\",\n          \"95% Confidence Intervals of Winning Probability\")+\n  xlab(NULL)+\n  ylab(NULL)+\n  labs(caption = glue::glue(\"{n_ties}/{n_sims} simulations excluded due to ties\"))\n\ngg\n```\n\n::: {.cell-output-display}\n![](quiz_with_balls_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nWhen team $A$ does better in the first round, the figure makes it clear that the\ngame is heavily tilted in favor of team $A$. In such scenarios, the simulation reveals that team $A$ wins more than 93.21% of games.[^4]\n\n[^4]: 93.21% is the lower-bound of the 95% confidence interval of the \none sided binomial test.\n\n\nAn even more compelling way to visualize the disparity is with final scores. The\nplot below shows the final scores for both teams after team $A$ is favored in\nthe first round. Lighter areas are point totals that are more common. Completely \nblue areas are score pairs that never occurred. Values below the diagonal $y=x$\nline correspond to team $A$ winning.\nIf you're familiar with the YouTuber John Bois, this is essentially a\n\"[scorigami](https://youtu.be/9l5C8cGMueY?feature=shared)\" diagram for \n*The Quiz With Balls*.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Plot Final Scores Favoring A\"}\ncounts <- \n  df |> \n  select(game_no, name, points) |> \n  tidyr::pivot_wider(names_from = \"name\",\n                     values_from = \"points\") |> \n  summarize(n = n(), .by = c(A,B))\n\nmin_points <-  min(df$points)\nmax_points <- max(df$points)\n\npossible_scores <- expand.grid(A = min_points:max_points,\n                               B = min_points:max_points)\n\ncounts <- \n  left_join(possible_scores, counts, by = c(\"A\",\"B\")) |> \n  mutate(n = ifelse(is.na(n),0,n))\n\n\ngg <- \n  ggplot(counts)+\n  geom_raster(aes(x=A,y=B,fill=n))+\n  geom_abline(aes(slope = 1,intercept = 0), col = \"white\")+\n  geom_text(aes(x=45,y=47),\n            label = \"Team A Wins Below This Line\",\n            col = \"white\", angle = 45,\n            family = \"Atkinson Hyperlegible\")+\n  xlim(c(8,65))+\n  ylim(c(8,65))+\n  coord_equal(expand=FALSE)+\n  xlab(\"Team A Final Score\")+\n  ylab(\"Team B Final Score\")+\n  labs(fill=\"Games\", caption = glue::glue(\"From {nrow(df)/2} Simulations\"))+\n  theme(legend.text = element_text(color = \"white\"),\n        legend.title = element_text(color = \"white\"),\n        legend.key = element_rect(color=\"white\"))+\n  ggtitle(\"Distribution of Final Scores When Favoring A\",\n          \"Thousands of Dollars\")\ngg\n```\n\n::: {.cell-output-display}\n![](quiz_with_balls_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nThere is barely any light above the diagonal line which means that team $B$\nalmost never scores more than team $A$. The game becomes strongly biased in \nfavor of the team that won the first round. \n\nThis also visualizes how complicated the scoring is for *The Quiz With Balls*. There are gaps between the lit up areas because certain point totals are impossible because of constraints on players and point multipliers.\n\n## Wrapping Up\n\n\n\n\n\nAn effective game show should keep the audience in suspense. Knowing the winner\nof an hour-long program at minute 10 is not ideal. The most likely outcome of\nthe first round is both teams losing a player. However, there's a \n27.78% chance that one team is favored going into the second\nround. And in those cases, the winner is determined more than \n93.21% of the time. So all in all, there's a 25.89%\nchance that you will know the winner after the first round.\n\nAnd if you're empirically minded, we can look at the results of the actual show.\nOf the first 5 episodes (the only episodes available at time of writing), 4/5\ngames go into round 2 favoring one team. In all of those games, the\nfavored team wins. In the other game, both teams lost a player in the first\nround. This sample is too small to trust, but it does provide initial evidence \nsupporting my claim that the first round often determines the outcome.\n",
    "supporting": [
      "quiz_with_balls_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}