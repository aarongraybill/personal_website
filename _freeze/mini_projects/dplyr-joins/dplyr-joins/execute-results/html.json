{
  "hash": "0f67e040916fe63e6836a0ea88e92cfd",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"dplyr's Lesser Known Joins and When to Use Them\"\nfrom: markdown+emoji\ndescription: \"I explain dplyr's semi_join, anti_join, and join_by commands, and when they might be useful to anyone who works with data.\"\nauthor: \"Aaron Graybill\"\ndate: \"4/28/2024\"\nexecute: \n  freeze: auto\ncategories: \n  - R\n  - dplyr\n  - data-science\neditor: \n  markdown: \n    wrap: 72\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Intro\n\n:::: {layout=\"[[30,-2,70]]\" layout-valign=\"center\"}\n\n::: {.intro-card}\n![](puzzle.svg){fig-alt=\"A puzzle fitting together\"}\n\n:::\n\n::: {intro-text}\n\nIn this post, I'll assume that you have some exposure to data wrangling\nin R using dplyr. If you're familiar with `mutate`, `summarize`, and in\nparticular, `(left/right/inner/full)_join`, you should have no problem.\n\n:::\n\n::::\n\n## Introducing the Working Data\n\nBefore I get into the joins, I will introduce the primary datasets for\nthis tutorial. You can expand the code below to see how I create the\ndata for this tutorial.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Click to see Code that Creates the Working Data\"}\n# Load dplyr without printing masking messages\nlibrary(dplyr, warn.conflicts = FALSE)\n\n## Get and clean Best New Artist data ----\nbest_new_artist_url <- 'https://en.wikipedia.org/w/index.php?title=Grammy_Award_for_Best_New_Artist&oldid=1205945357'\nhtml_content <- rvest::read_html(best_new_artist_url)\n\n# Convert each html table to a dataframe\ntables <- \n  rvest::html_nodes(html_content, \"table\") %>% \n  lapply(rvest::html_table)\n\n# For each table on the page, only keep tables that have the correct\n# column names\ncorrect_columns <- c(\"Year[I]\",\"Recipient\", \"Nominees\")\nnew_artist_tables <- tables[sapply(tables,function(df) {all(correct_columns %in% colnames(df))})]\n\n# Combine multiple tables into one table\nbest_new_artists <- bind_rows(new_artist_tables)\n\n# Clean up names and fix types\nbest_new_artists <- \n  best_new_artists %>% \n  select(\n    year = `Year[I]`,\n    recipient = Recipient\n  ) %>% \n  mutate(year = as.integer(year))\n\n## Get and Album of the Year data ----\nalbum_of_the_year_url <- 'https://en.wikipedia.org/w/index.php?title=Grammy_Award_for_Album_of_the_Year&oldid=1208622825'\nhtml_content <- rvest::read_html(album_of_the_year_url)\n\n# Convert each html table to a dataframe\ntables <- \n  rvest::html_nodes(html_content, \"table\") %>% \n  lapply(rvest::html_table)\n\n# For each table on the page, only keep tables that have the correct\n# column names\ncorrect_columns <- correct_columns <- c(\"Year[a]\",\"Album\", \"Artist(s)\")\nalbum_of_the_year_tables <- tables[sapply(tables,function(df) {all(correct_columns %in% colnames(df))})]\n\n# Combine multiple tables into one table\nalbums_of_the_year <- bind_rows(album_of_the_year_tables)\n\n# Remove missing awards, and remove suffix from year\nalbums_of_the_year <- \n  albums_of_the_year %>% \n  filter(!is.na(Album)) %>% \n  mutate(`Year[a]` = substr(`Year[a]`,1,4))\n\n# For each year, get only the first year (which is the winner). The removed\n# rows are non-winning nominees\nalbums_of_the_year <- \n  albums_of_the_year %>% \n  slice_head(n=1, by = `Year[a]`)\n\n# Clean up names and fix types\nalbums_of_the_year <- \n  albums_of_the_year %>% \n  select(\n    year = `Year[a]`,\n    album = Album,\n    artists = `Artist(s)`\n  ) %>% \n  mutate(year = as.integer(year))\n\n# Only keep what we need\nrm(list = setdiff(ls(),c( \"albums_of_the_year\", \"best_new_artists\")))\n```\n:::\n\n\n\n\nFor this tutorial I have two primary datasets, both scraped from\nWikipedia. First, `best_new_artists` is the list of winners of the\nGrammy's \"Best New Artist\" Award from 1960 to 2024. This data has two\ncolumns, `year` (the year of the award) and `recipient` (the winner of\nthe award). The end of the data looks like this:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(best_new_artists)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n   year recipient          \n  <int> <chr>              \n1  2019 Dua Lipa           \n2  2020 Billie Eilish      \n3  2021 Megan Thee Stallion\n4  2022 Olivia Rodrigo     \n5  2023 Samara Joy         \n6  2024 Victoria Monét     \n```\n\n\n:::\n:::\n\n\n\n\nThe other dataset in this tutorial is `albums_of_the_year` which\ncontains the winners of the Grammy's \"Album of the Year\" award from\n1959-2024. This dataset has three columns: `year` (the year of the\naward), `album` (the title of the winning album), and `artists` (the\nartist(s) who made the album).\n\nThe last few rows of this dataset are:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntail(albums_of_the_year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n   year album                                    artists        \n  <int> <chr>                                    <chr>          \n1  2019 Golden Hour                              Kacey Musgraves\n2  2020 When We All Fall Asleep, Where Do We Go? Billie Eilish  \n3  2021 Folklore                                 Taylor Swift   \n4  2022 We Are                                   Jon Batiste    \n5  2023 Harry's House                            Harry Styles   \n6  2024 Midnights                                Taylor Swift   \n```\n\n\n:::\n:::\n\n\n\n\nGoing forward, I will ask questions about how these two datasets\ninteract.\n\n## `semi_join` (everything from dataset `x` that matches dataset `y`)\n\nThe `semi_join` command is like a version of dplyr's `filter` command\nthat works between two datasets.\n\n### Basic Usage of `semi_join`\n\nI think the easiest way to learn how to use these dplyr commands is to\nuse them to answer motivating questions. A motivating question for\n`semi_join` could be:\n\n> Which winners of Best New Artist ever won Album of the Year?\n\nThe code below uses a `semi_join` to return all of the best new artists\nwhere the `recipient` field matches the `artists` field from the album\nof the year data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsemi_join(\n  best_new_artists,\n  albums_of_the_year,\n  by = c(\"recipient\" = \"artists\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 2\n   year recipient        \n  <int> <chr>            \n1  1961 Bob Newhart      \n2  1965 The Beatles      \n3  1976 Natalie Cole     \n4  1981 Christopher Cross\n5  1999 Lauryn Hill      \n6  2003 Norah Jones      \n7  2009 Adele            \n8  2020 Billie Eilish    \n```\n\n\n:::\n:::\n\n\n\n\nNotice that not all winners of Best New Artist appear here. For example\nOlivia Rodrigo won Best New Artist in 2022, but has not (yet) won Album\nof the Year.\n\nThe Beatles won album of the year in 1968 for *Sgt. Pepper's Lonely\nHearts Club* *Band*, but this `semi_join` is only showing us the Beatles\nin 1965. Where's *Sgt. Peppers*? This result is actually by design!\n`semi_join` only returns rows and columns from the first dataset.\n\nIf you're like me, you might initially have a hard time distinguishing\n`semi_join` from `inner_join`. The key difference is that the\n`semi_join`. Only has the columns from the first dataset. Compare the\nresults of the `semi_join` (above) to the equivalent `inner_join`\n(below):\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninner_join(\n  best_new_artists,\n  albums_of_the_year,\n  by = c(\"recipient\" = \"artists\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 4\n  year.x recipient         year.y album                                   \n   <int> <chr>              <int> <chr>                                   \n1   1961 Bob Newhart         1961 The Button-Down Mind of Bob Newhart     \n2   1965 The Beatles         1968 Sgt. Pepper's Lonely Hearts Club Band   \n3   1976 Natalie Cole        1992 Unforgettable... with Love              \n4   1981 Christopher Cross   1981 Christopher Cross                       \n5   1999 Lauryn Hill         1999 The Miseducation of Lauryn Hill         \n6   2003 Norah Jones         2003 Come Away with Me                       \n7   2009 Adele               2012 21                                      \n8   2009 Adele               2017 25                                      \n9   2020 Billie Eilish       2020 When We All Fall Asleep, Where Do We Go?\n```\n\n\n:::\n:::\n\n\n\n\nNotice that we now have a `year.x` column (the year of the Best New\nArtist award) and a `year.y` column (the year of the Album of the Year).\n\n### `semi_join`ing on Multiple Columns\n\nJust like any other dplyr join, you can `semi_join` on mutliple columns.\nThis allows us to answer questions like:\n\n> Which winners of Best New Artist won Album of the Year in the same\n> year as Best New Artist award?\n\nContrast this with our question from before:\n\n> Which winners of Best New Artist ever won Album of the Year?\n\nNow we're only asking for years where the Album of the Year and the Best\nNew Artist occur simultaneously. To accomplish this, we can join on both\nartist and the year of the award:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsemi_join(\n  best_new_artists,\n  albums_of_the_year,\n  by = c(\"recipient\" = \"artists\", \"year\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n   year recipient        \n  <int> <chr>            \n1  1961 Bob Newhart      \n2  1981 Christopher Cross\n3  1999 Lauryn Hill      \n4  2003 Norah Jones      \n5  2020 Billie Eilish    \n```\n\n\n:::\n:::\n\n\n\n\nA very short list! Again notice that `semi_join` does not return the\nactual album, we would require a \"mutating\" join, like\n`left/right/inner/full` to get the album name as well.\n\n## When to Use `semi_join`\n\nI often use `semi_join` when I have complicated dataset that I need to\nfilter on a few conditions.\n\nFor example, I might have a dataset of multiple timeseries of economic\nindicators at the county level. And then, due to a research question, we\nhave identified specific combinations of counties and years that are\ninteresting. I could use `semi_join` to get the values of the economic\nindicators only in the years and counties that we are interested in.\n\n## `anti_join` (everything from dataset `x` that doesn't match dataset `y`)\n\n### Basic Usage\n\nThe `anti_join` function is essentially the opposite of `semi_join`.\nRecall that `semi_join` was used to answer questions like:\n\n> Which winners of Best New Artist ever won Album of the Year?\n\n`anti_join` can be used to answer questions like:\n\n> Which winners of Best New Artist **never** won Album of the Year?\n\nThat is, `anti_join` returns all of the rows in the first dataset, that\ndo not have a match in the second dataset. See the example below:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanti_join(\n  best_new_artists,\n  albums_of_the_year,\n  by = c(\"recipient\" = \"artists\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 57 × 2\n    year recipient            \n   <int> <chr>                \n 1  1960 Bobby Darin          \n 2  1962 Peter Nero           \n 3  1963 Robert Goulet        \n 4  1964 The Swingle Singers  \n 5  1966 Tom Jones            \n 6  1967 No award             \n 7  1968 Bobbie Gentry        \n 8  1969 José Feliciano       \n 9  1970 Crosby, Stills & Nash\n10  1971 The Carpenters       \n# ℹ 47 more rows\n```\n\n\n:::\n:::\n\n\n\n\nSimilar to `semi_join`, `anti_join` only returns rows and columns from\nthe first dataset, so the results above do not include any of the\ncolumns from the Album of the Year dataset.\n\n## `anti_join` on Multiple columns\n\nWhen using `anti_join` on multiple columns, we return all of the rows\nfrom the first dataset, that do not match all of the columns in the\nsecond dataset. This allows us to answer questions like:\n\n> Which winners of Best New Artists were not Album of the Year Winners\n> in their same year that they won their Best New Artist Award?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanti_join(\n  best_new_artists,\n  albums_of_the_year,\n  by = c(\"recipient\" = \"artists\", \"year\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 60 × 2\n    year recipient            \n   <int> <chr>                \n 1  1960 Bobby Darin          \n 2  1962 Peter Nero           \n 3  1963 Robert Goulet        \n 4  1964 The Swingle Singers  \n 5  1965 The Beatles          \n 6  1966 Tom Jones            \n 7  1967 No award             \n 8  1968 Bobbie Gentry        \n 9  1969 José Feliciano       \n10  1970 Crosby, Stills & Nash\n# ℹ 50 more rows\n```\n\n\n:::\n:::\n\n\n\n\nThe example above is a bit contrived, but notice that there is no value\nfor the year 1961. That is because in 1961 Bob Newhart won both Best New\nArtist and Album of the Year (in the same year), so he would not appear\nin the `anti_join`.\n\nFurther notice that the Beatles *do* appear in the `anti_join` despite\nhaving won both Best New Artist and Album of the Year. They appear\nbecause their Album of the Year win and Best New Artist win occurred in\ndifferent years.\n\n## When to Use `anti_join`\n\nI have found `anti_join` useful in two main situations. The first\nsituation is when I need to exclude/remove problematic entries in a\ndataframe. For example, if I have figured out that all of the data from\ncertain counties is wrong, I might wish to exclude that from subsequent\nanalysis. Adding an `anti_join` on state and county would remove only\nthe records corresponding to these problematic counties.\n\nMy other use for `anti_join` is as a debugger. Sometimes when I'm\nbuilding a complicated join that isn't working as expected, I will\nreplace the `(left/full/semi)_join` with an `anti_join` to see which\nrecords are not being matched between datasets. Isolating just the\nunmatched records allows you to quickly see if there's anything off\nabout those rows like capitalization, `NA`s, etc.\n\n## `join_by` (inequality conditions with other joins)\n\ndplyr's `join_by` function was the inspiration for this tutorial. It\nallows you to quickly implement complex joins that would feel almost\nimpossible otherwise.\n\n### Basic Usage\n\nUnlike the other functions in this tutorial `join_by` appears *inside*\nof other joins. Effectively, `join_by` creates a more specific version\nof what is normally specified in the `by = c(...)` argument. For\nexample, the following two joins are equivalent.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_regular <- semi_join(\n  best_new_artists,\n  albums_of_the_year,\n  by = c(\"recipient\" = \"artists\")\n)\n\ndf_join_by <- semi_join(\n  best_new_artists,\n  albums_of_the_year,\n  by = join_by(recipient == artists)\n)\n\n# print out dataframe\ndf_join_by\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 2\n   year recipient        \n  <int> <chr>            \n1  1961 Bob Newhart      \n2  1965 The Beatles      \n3  1976 Natalie Cole     \n4  1981 Christopher Cross\n5  1999 Lauryn Hill      \n6  2003 Norah Jones      \n7  2009 Adele            \n8  2020 Billie Eilish    \n```\n\n\n:::\n\n```{.r .cell-code}\n# make sure two methods are exactly the same\nall.equal(df_regular,df_join_by)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n\n\nJust to refresh on what `semi_join` is doing, in the above, we are\nanswering the question:\n\n> Which Best New Artist winners also won Album of the Year?\n\nNotice that in the `join_by` example above, I am using unquoted variable\nnames and the binary operator `==` instead of the assignment operator\n`=`. This is because `join_by` allows for inequality conditions as well!\n`join_by` allows us to ask complicated complicated questions like:\n\n> For the people who won both Album of the Year and Best New Artist,\n> which Best New Artist winners won their award before they won Album of\n> the Year?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsemi_join(\n  best_new_artists,\n  albums_of_the_year,\n  by = join_by(recipient == artists,\n               year < year)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n   year recipient   \n  <int> <chr>       \n1  1965 The Beatles \n2  1976 Natalie Cole\n3  2009 Adele       \n```\n\n\n:::\n:::\n\n\n\n\nNotice that this list is much smaller than the previous join! That's\nbecause everyone who is now excluded won their Best New Artist award *in\nthe same year* as their Best New Artist award.\n\nThe above code is much more elegant than an equivalent implementation\nusing the basic `by = c(...)` syntax.\n\n### Advanced Usage\n\nWe have already discussed `join_by`'s inequality joins, but it can\nactually do even more than this! I'll point you to [the documentation\nfor `join_by`](https://dplyr.tidyverse.org/reference/join_by.html) which\ndetails all of the available options.\n\nBut as a teaser, I will tell you about the `closest` option. Let's say\nyou have two datasets. One is a dataset of the dates that a baseball\nplayer is traded between teams. The other dataset is the dates where\nthat player has played in games. If you wanted to find this player's\nfirst game with each team, you could use something like\n`join_by(closest(game_date >= trade_date))` which would only match *the\nfirst game* that appears on or after the trade date!\n\nOf course, this example is contrived, but the `closest` option can be\nextremly useful when the data you're working with is large.\n\n### When to Use `join_by`\n\nOften, there are ways to avoid using join by using clever `join`s and\n`filter`s, but `join_by` can make this code much more clear. In\naddition, doing `join` and then `filter` often returns way more results\nthan are actually needed before the `filter` occurs. When working with\nlarge datasets, often the full results of the `join` will not fit in\nyour computer's memory, so you have to use a `join_by` to return only\nthe results that are needed.\n\nI find `join_by` most useful when I have two datasets that both have\ndates that don't match exactly. Here `join_by` allows me to look at\nwhich records from one dataset are closest or contained within the dates\nof another.\n\n## Wrapping Up :gift:\n\nIn this post I explained how to use dplyr's `semi_join`, `anti_join`,\nand `join_by` functions. These functions can be very helpful to anyone\nwho works with data!\n\nPlease feel free to leave a comment below if you have any questions!\n",
    "supporting": [
      "dplyr-joins_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}